{"title":"Stratification and sampling️ of population centers in Loreto, Peru 🎲✨","markdown":{"yaml":{"title":"Stratification and sampling️ of population centers in Loreto, Peru 🎲✨","number-sections":true,"format":{"html":{"code-fold":true,"code-summary":"Show code","toc":true}},"editor":"visual"},"headingText":"| echo: false","containsRefs":false,"markdown":"\n\n```{r}\n#| warning: false\n#| message: false\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(leaflet)\nlibrary(sf)\nlibrary(reactable)\nlibrary(purrr)\nlibrary(cluster)\nlibrary(pheatmap)\nlibrary(factoextra)\nlibrary(FactoMineR)\nlibrary(yardstick)\nlibrary(mapview)\n```\n\n```{css, echo=FALSE}\n.panel-tabset .nav-item {\n  font-size: 10px;\n  font-style: italic\n}\n```\n\n## Introduction {#intro}\n\nThis document describes the methodology carried out for the stratification and selection of population centers in Loreto for drone surveillance. This activity is part of the the *Harmonize project: Harmonisation of spatio-temporal multi-scale data for health in climate change hotspots in the Peruvian Amazon* (SIDISI 209821), in collaboration with the Barcelona Supercomputing Center.\n\nThe Harmonize project has the following objectives:\n\n1)  Geo-location of cases collected by passive surveillance from the Peruvian Ministry of Health (MINSA) through the Center for Disease Control and Prevention (CDC-Peru) in the study area using GPS devices.\n\n2)  Identify potential mosquito breeding sites based on new longitudinal ground survey data and using drone surveillance.\n\n3)  Collect data from weather stations, satellite imagery, ambient acoustic sounds and air pollution to calibrate and reduce the spatial resolution of Earth observation data sets.\n\n4)  Determine the impact of the use of these new technologies on infectious disease reduction interventions carried out by the Dirección Regional de Salud (DIRESA) of Loreto.\n\nThe methodology described here corresponds to the second objective above. Since we cannot map the whole study area of Loreto, our approach was to characterize the population centers in Loreto according to the incidence of relevant diseases in the area (Malaria, Dengue and Leptospirosis) and meteorological, environmental and human intervention variables (temperature, precipitation, soil moisture, deforestation, etc.) and then use this variables to create sampling strata using clustering techniques. Finally, we randomly sampled a number of the population centers from each stratum proportional to the stratum size.\n\n## Dataset {#dataset}\n\nFor each population center, we gathered records on the following fields:\n\n-   UBIGEO, which is the official identification code of the population centers used by the Instituto Nacional de Estadística e Informática (INEI).\n-   Official name .\n-   Latitude and longitud.\n-   Cumulative incidence of malaria, dengue and leptospirosis from epidemiological week 1 to 39 of 2022.\n-   Mean and difference of the annual mean values of the years 2010 and 2021 of the following variables:\n    -   Precipitation accumulation (mm),\n    -   Runoff (mm),\n    -   Soil moisture (mm),\n    -   Maximum temperature (°C),\n    -   Minimum temperature (°C),\n    -   Total evapotranspiration (kg/m^2^),\n    -   Specific humidity (kg/kg),\n    -   Deforestation area (km^2^).\n-   Mean and difference of the annual values of the years 2010 and 2020 of the following variables:\n    -   Population density from WorldPop and\n    -   Human settlement data from the Global Human Settlement Layer (GHSL).\n-   Mean and difference of the annual mean values from years 2014 and 2021 of the nighttime data from the Visible Infrared Imaging Radiometer Suite (VIIRS).\n\nWe can take a look at the data in the following table:\n\n```{r}\n#| echo: false\ndataset = readr::read_csv(\"data/processed/dataset.csv\", col_types = \"ccd\")\n```\n\n```{r}\ndataset %>% \n  mutate(across(where(is.numeric), ~ round(.x, 2))) %>% \n  DT::datatable(\n    options = list(display = \"compact\", pageLength = 5, scrollX = TRUE)\n  )\n```\n\n## Stratification\n\nThe stratification of the population centers consisted of using the meteorological, environmental and human intervention variables to built groups of population centers with homogeneous characteristics. For this purpose, we tested two approaches. The first one consisted of performing an agglomerative (\"bottom-up\") hierarchical clustering analysis using different distances, linkage methods, and number of clusters selection methods. On the second one, we used Principal Component Analysis (PCA) to reduce the dimension of the variables to one principal dimension and used it's scores to create groups by quantile classification.\n\n#### Hierarchical clustering\n\n```{r}\n#| echo: false\nvariables = select(dataset, malaria:malaria_diff)\n```\n\n```{r}\n#| echo: false\nvariables_norm = mutate(variables, across(everything(), scales::rescale))\nvariables_std = mutate(variables, across(everything(), ~as.numeric(scale(.x))))\n```\n\n```{r}\ndist_euclidean_norm = get_dist(variables_norm, method = \"euclidean\")\ndist_pearson_norm = get_dist(variables_norm, method = \"pearson\")\ndist_spearman_norm = get_dist(variables_norm, method = \"spearman\")\ndist_euclidean_std = get_dist(variables_std, method = \"euclidean\")\ndist_pearson_std = get_dist(variables_std, method = \"pearson\")\ndist_spearman_std = get_dist(variables_std, method = \"spearman\")\n```\n\n### 🔵 Heatmaps\n\n#### Normalization\n\n::: panel-tabset\n##### Euclidean distance\n\n```{r}\n#| echo: false\npheatmap(dist_euclidean_norm)\n```\n\n##### Pearson correlation\n\n```{r}\n#| echo: false\npheatmap(dist_pearson_norm)\n```\n\n##### Spearman correlation\n\n```{r}\n#| echo: false\npheatmap(dist_spearman_norm)\n```\n:::\n\n#### Standardization\n\n::: panel-tabset\n##### Euclidean distance\n\n```{r}\n#| echo: false\npheatmap(dist_euclidean_std)\n```\n\n##### Pearson correlation\n\n```{r}\n#| echo: false\npheatmap(dist_pearson_std)\n```\n\n##### Spearman correlation\n\n```{r}\n#| echo: false\npheatmap(dist_spearman_std)\n```\n:::\n\n### 🔵 Selection of distance and linkage method\n\n```{r}\n#| echo: false\nscale_data = function(data, method = \"standardization\") {\n  if (method == \"standardization\") {\n    data_scaled = mutate(data, across(everything(), ~as.numeric(scale(.x))))\n  } \n  if (method == \"normalization\") {\n    data_scaled = mutate(data, across(everything(), scales::rescale))\n  }\n  data_scaled\n}\n```\n\n```{r}\n#| echo: false\nscaling_method = c(\"standardization\", \"normalization\")\ndist_method = c(\"euclidean\", \"pearson\", \"spearman\")\nlinkage_method = c(\"average\", \"single\", \"complete\", \"ward\", \"weighted\")\n```\n\n```{r}\n#| echo: false\ndesign = tidyr::expand_grid(scaling_method, dist_method, linkage_method, variables)\n```\n\n```{r}\n#| echo: false\nagglomerative_coeff = design %>% \n  tidyr::nest(data = -c(scaling_method, dist_method, linkage_method)) %>% \n  mutate(\n    scaling = map2(data, scaling_method, ~scale_data(.x, method = .y)),\n    dist_mat = map2(scaling, dist_method, ~get_dist(.x, method = .y)),\n    tree = map2(dist_mat, linkage_method, ~agnes(.x, method = .y)),\n    ac = map(tree, ~.x$ac)\n  ) %>% \n  tidyr::unnest(ac) %>% \n  arrange(-ac)\n```\n\n```{r}\nagglomerative_coeff %>% \n  select(-c(data, scaling, dist_mat, tree)) %>% \n  DT::datatable()\n```\n\n#### Dendograms\n\n::: panel-tabset\n#### Standardization, Spearman correlation, Ward linkage\n\n```{r}\n#| echo: false\n#| warning: false\n#| message: false\nfviz_dend(\n  agglomerative_coeff$tree[[1]], main = \"Standardized data - Spearman correlation - Ward linkage\"\n)\n```\n\n#### Normalization, Pearson correlation, Ward linkage\n\n```{r}\n#| echo: false\n#| warning: false\n#| message: false\nfviz_dend(\n  agglomerative_coeff$tree[[2]], main = \"Normalized data - Pearson correlation - Ward linkage\"\n)\n```\n:::\n\n### 🔵 Selection of number of clusters\n\nSelection of the number of clusters: The criteria of average silhouette width, total within sum of squares and gap statistic were used to select the number of clusters. Dimension reduction (PCA) was also used to visualize the data in 2 dimensions for different numbers of clusters and to evaluate how well the groups were formed. Furthermore, for different numbers of clusters, the differences between the means of the variables in different clusters were explored for cluster interpretability. Finally, the individual silhouette of each observation was evaluated for different numbers of clusters to assess whether the observations were well grouped. The final selection was made by evaluating all these criteria and selecting the most suitable number of clusters for the application.\n\n#### Evaluation of criteria\n\n##### Standardization, Spearman correlation, Ward linkage\n\n::: panel-tabset\n###### Average silhouette width\n\n```{r}\n#| echo: false\nset.seed(2022)\nfviz_nbclust(\n  variables_std, hcut, hc_func = \"agnes\", hc_method = \"ward.D2\", \n  c_metric = \"spearman\", method = \"silhouette\"\n)\n```\n\n###### Total within sum of squares\n\n```{r}\n#| echo: false\nfviz_nbclust(\n  variables_std, hcut, hc_func = \"agnes\", hc_method = \"ward.D2\", hc_metric = \"spearman\", \n  method = \"wss\"\n)\n```\n\n###### Gap statistic\n\n```{r}\n#| echo: false\nset.seed(2022)\nfviz_nbclust(\n  variables_std, hcut, hc_func = \"agnes\", hc_method = \"ward.D2\", \n  hc_metric = \"spearman\", method = \"gap_stat\"\n)\n```\n:::\n\n##### Normalization, Pearson correlation, Ward linkage\n\n::: panel-tabset\n###### Average silhouette width\n\n```{r}\n#| echo: false\nset.seed(2022)\nfviz_nbclust(\n  variables_norm, hcut, hc_func = \"agnes\", hc_method = \"ward.D2\", \n  c_metric = \"pearson\", method = \"silhouette\"\n)\n```\n\n###### Total within sum of squares\n\n```{r}\n#| echo: false\nfviz_nbclust(\n  variables_norm, hcut, hc_func = \"agnes\", hc_method = \"ward.D2\", hc_metric = \"pearson\", \n  method = \"wss\"\n)\n```\n\n###### Gap statistic\n\n```{r}\n#| echo: false\nset.seed(2022)\nfviz_nbclust(\n  variables_norm, hcut, hc_func = \"agnes\", hc_method = \"ward.D2\", \n  hc_metric = \"pearson\", method = \"gap_stat\"\n)\n```\n:::\n\n#### Evaluation of cluster sizes\n\n##### 2 clusters\n\n```{r}\nclustering_2 = hcut(\n  variables_std, k = 2, hc_func = \"agnes\", hc_method = \"ward.D2\", \n  hc_metric = \"spearman\"\n)\n```\n\n::: panel-tabset\n###### Clusters on plane\n\n```{r}\n#| echo: false\nfviz_cluster(clustering_2, ggtheme = theme_classic()) +\n  geom_vline(xintercept = 0, linetype = \"dashed\") +\n  geom_hline(yintercept = 0, linetype = \"dashed\")\n```\n\n###### Individual silhouette\n\n```{r}\n#| echo: false\nfviz_silhouette(clustering_2, ggtheme = theme_classic())\n```\n\n###### Mean difference between clusters\n\n```{r}\n#| echo: false\nvariables_norm %>% \n  mutate(group = as.factor(clustering_2$cluster)) %>% \n  group_by(group) %>% \n  summarise(across(everything(), mean), .groups = \"drop\") %>% \n  tidyr::pivot_longer(-group) %>% \n  ggplot(aes(group, value, color = name, group = name)) +\n  geom_point() +\n  geom_line() +\n  scale_x_discrete(expand = c(0.05, 0.05)) +\n  theme_classic()\n```\n:::\n\n##### 3 clusters\n\n```{r}\nclustering_3 = hcut(\n  variables_std, k = 3, hc_func = \"agnes\", hc_method = \"ward.D2\", \n  hc_metric = \"spearman\"\n)\n```\n\n::: panel-tabset\n###### Clusters on plane\n\n```{r}\n#| echo: false\nfviz_cluster(clustering_3, ggtheme = theme_classic()) +\n  geom_vline(xintercept = 0, linetype = \"dashed\") +\n  geom_hline(yintercept = 0, linetype = \"dashed\")\n```\n\n###### Individual silhouette\n\n```{r}\n#| echo: false\nfviz_silhouette(clustering_3, ggtheme = theme_classic())\n```\n\n###### Mean difference between clusters\n\n```{r}\n#| echo: false\nvariables_norm %>% \n  mutate(group = as.factor(clustering_3$cluster)) %>% \n  group_by(group) %>% \n  summarise(across(everything(), mean), .groups = \"drop\") %>% \n  tidyr::pivot_longer(-group) %>% \n  ggplot(aes(group, value, color = name, group = name)) +\n  geom_point() +\n  geom_line() +\n  scale_x_discrete(expand = c(0.05, 0.05)) +\n  theme_classic()\n```\n:::\n\n##### 4 clusters\n\n```{r}\nclustering_4 = hcut(\n  variables_std, k = 4, hc_func = \"agnes\", hc_method = \"ward.D2\", \n  hc_metric = \"spearman\"\n)\n```\n\n::: panel-tabset\n###### Clusters on plane\n\n```{r}\n#| echo: false\nfviz_cluster(clustering_4, ggtheme = theme_classic()) +\n  geom_vline(xintercept = 0, linetype = \"dashed\") +\n  geom_hline(yintercept = 0, linetype = \"dashed\")\n```\n\n###### Individual silhouette\n\n```{r}\n#| echo: false\nfviz_silhouette(clustering_4, ggtheme = theme_classic())\n```\n\n###### Mean difference between clusters\n\n```{r}\n#| echo: false\nvariables_norm %>% \n  mutate(group = as.factor(clustering_4$cluster)) %>% \n  group_by(group) %>% \n  summarise(across(everything(), mean), .groups = \"drop\") %>% \n  tidyr::pivot_longer(-group) %>% \n  ggplot(aes(group, value, color = name, group = name)) +\n  geom_point() +\n  scale_x_discrete(expand = c(0.05, 0.05)) +\n  geom_line() +\n  theme_classic()\n```\n:::\n\n### 🔵 Maps\n\n```{r}\ndataset_clustering = dataset %>% \n  mutate(\n    hc_group_2 = as.factor(clustering_2$cluster),\n    hc_group_3 = as.factor(clustering_3$cluster),\n    hc_group_4 = as.factor(clustering_4$cluster)\n  )\n```\n\n::: panel-tabset\n#### 2 clusters\n\n```{r}\n#| echo: false\n#| warning: false\n#| message: false\npaleta = colorFactor(palette = \"viridis\",domain = dataset_clustering$hc_group_2)\ndataset_clustering %>% \n  st_as_sf(coords = c(\"lon\", \"lat\"),crs=4326) %>%\n  leaflet() %>% \n  addTiles(group = \"OpenStreetMap\") %>% \n  addProviderTiles(provider = providers$CartoDB,group = \"CartoDB\") %>%\n  addProviderTiles(provider = providers$Esri.WorldImagery,group = \"Satelital\") %>% \n  addCircleMarkers(\n    popup = dataset_clustering$village,\n    color = ~paleta(hc_group_2),\n    opacity = 1,\n    radius = 0.1,\n    fillOpacity = 0.5\n    )%>% \n  addLayersControl(\n    baseGroups = c(\"CartoDB\",\"OpenStreetMap\",\"Satelital\")\n    ) %>% \n  addLegend(\n    title = \"Cluster\",\n    pal = paleta,\n    values = ~hc_group_2,\n    opacity = 1,\n    position = \"bottomright\"\n    )\n```\n\n#### 3 clusters\n\n```{r}\n#| echo: false\n\npaleta = colorFactor(palette = \"viridis\",domain = dataset_clustering$hc_group_3)\ndataset_clustering %>% \n  st_as_sf(coords = c(\"lon\", \"lat\"),crs=4326) %>%\n  leaflet() %>% \n  addTiles(group = \"OpenStreetMap\") %>% \n  addProviderTiles(provider = providers$CartoDB,group = \"CartoDB\") %>%\n  addProviderTiles(provider = providers$Esri.WorldImagery,group = \"Satelital\") %>% \n  addCircleMarkers(\n    popup = dataset_clustering$village,\n    color = ~paleta(hc_group_3),\n    opacity = 1,\n    radius = 0.1,\n    fillOpacity = 0.5\n    )%>% \n  addLayersControl(\n    baseGroups = c(\"CartoDB\",\"OpenStreetMap\",\"Satelital\")\n    ) %>% \n  addLegend(\n    title = \"Cluster\",\n    pal = paleta,\n    values = ~hc_group_3,\n    opacity = 1,\n    position = \"bottomright\"\n    )\n```\n\n#### 4 clusters\n\n```{r}\n#| echo: false\npaleta = colorFactor(palette = \"viridis\",domain = dataset_clustering$hc_group_4)\ndataset_clustering %>% \n  st_as_sf(coords = c(\"lon\", \"lat\"),crs=4326) %>%\n  leaflet() %>% \n  addTiles(group = \"OpenStreetMap\") %>% \n  addProviderTiles(provider = providers$CartoDB,group = \"CartoDB\") %>%\n  addProviderTiles(provider = providers$Esri.WorldImagery,group = \"Satelital\") %>% \n  addCircleMarkers(\n    popup = dataset_clustering$village,\n    color = ~paleta(hc_group_4),\n    opacity = 1,\n    radius = 0.1,\n    fillOpacity = 0.5\n    )%>% \n  addLayersControl(\n    baseGroups = c(\"CartoDB\",\"OpenStreetMap\",\"Satelital\")\n    ) %>% \n  addLegend(\n    title = \"Cluster\",\n    pal = paleta,\n    values = ~hc_group_4,\n    opacity = 1,\n    position = \"bottomright\"\n    )\n```\n:::\n\n### 🔵 Principal components analysis\n\nThe communities were also tested for clustering using the principal component that best explained the variability of the variables used (first component). The scores of this component were divided into different categories given by the quantiles. Three forms of clustering were tested: 2 groups with the 50% quantile, 3 groups with the 33% and 66% quantiles, and 4 groups with the 25%, 50% and 75% quantiles.\n\n```{r}\npca = PCA(variables_std, graph = FALSE)\n```\n\n#### Scree plot\n\n```{r}\nfviz_screeplot(pca)\n```\n\n#### Contribution plot\n\n::: panel-tabset\n##### Dimension 1\n\n```{r}\nfviz_contrib(pca, choice = \"var\", axes = 1, top = 10)\n```\n\n##### Dimension 2\n\n```{r}\nfviz_contrib(pca, choice = \"var\", axes = 2, top = 10)\n```\n:::\n\n### 🔵 Coordinate plane\n\n```{r}\nfviz_pca_ind(pca)\n```\n\n### 🔵 Maps\n\n```{r}\npca_results = get_pca_ind(pca)\nscores = pca_results$coord\n```\n\n```{r}\ndataset_pca = dataset_clustering %>% \n  mutate(pca_score = scores[, 1]) %>% \n  mutate(\n    pca_group_2 = cut(\n      pca_score, breaks = quantile(pca_score, c(0, .5, 1)), \n      labels = as.character(rev(1:2)),\n      include.lowest = TRUE\n    ),\n    pca_group_3 = cut(\n      pca_score, breaks = quantile(pca_score, c(0, .33, .66, 1)), \n      labels = as.character(rev(1:3)),\n      include.lowest = TRUE\n    ),\n    pca_group_4 = cut(\n      pca_score, breaks = quantile(pca_score, c(0, .25, .5, .75, 1)), \n      labels = as.character(rev(1:4)),\n      include.lowest = TRUE\n    )\n  ) %>% \n  mutate(across(pca_group_2:pca_group_4, forcats::fct_rev))\n```\n\n::: panel-tabset\n#### 2 groups\n\n```{r}\npaleta = colorFactor(palette = \"viridis\",domain = dataset_pca$pca_group_2)\ndataset_pca %>% \n  st_as_sf(coords = c(\"lon\", \"lat\"),crs=4326) %>%\n  leaflet() %>% \n  addTiles(group = \"OpenStreetMap\") %>% \n  addProviderTiles(provider = providers$CartoDB,group = \"CartoDB\") %>%\n  addProviderTiles(provider = providers$Esri.WorldImagery,group = \"Satelital\") %>% \n  addCircleMarkers(\n    popup = dataset_pca$village,\n    color = ~paleta(pca_group_2),\n    opacity = 1,\n    radius = 0.1,\n    fillOpacity = 0.5\n    )%>% \n  addLayersControl(\n    baseGroups = c(\"CartoDB\",\"OpenStreetMap\",\"Satelital\")\n    ) %>% \n  addLegend(\n    title = \"Cluster\",\n    pal = paleta,\n    values = ~pca_group_2,\n    opacity = 1,\n    position = \"bottomright\"\n    )\n```\n\n#### 3 groups\n\n```{r}\npaleta = colorFactor(palette = \"viridis\",domain = dataset_pca$pca_group_3)\ndataset_pca %>% \n  st_as_sf(coords = c(\"lon\", \"lat\"),crs=4326) %>%\n  leaflet() %>% \n  addTiles(group = \"OpenStreetMap\") %>% \n  addProviderTiles(provider = providers$CartoDB,group = \"CartoDB\") %>%\n  addProviderTiles(provider = providers$Esri.WorldImagery,group = \"Satelital\") %>% \n  addCircleMarkers(\n    popup = dataset_pca$village,\n    color = ~paleta(pca_group_3),\n    opacity = 1,\n    radius = 0.1,\n    fillOpacity = 0.5\n    )%>% \n  addLayersControl(\n    baseGroups = c(\"CartoDB\",\"OpenStreetMap\",\"Satelital\")\n    ) %>% \n  addLegend(\n    title = \"Cluster\",\n    pal = paleta,\n    values = ~pca_group_3,\n    opacity = 1,\n    position = \"bottomright\"\n    )\n```\n\n#### 4 groups\n\n```{r}\npaleta = colorFactor(palette = \"viridis\",domain = dataset_pca$pca_group_4)\ndataset_pca %>% \n  st_as_sf(coords = c(\"lon\", \"lat\"),crs=4326) %>%\n  leaflet() %>% \n  addTiles(group = \"OpenStreetMap\") %>% \n  addProviderTiles(provider = providers$CartoDB,group = \"CartoDB\") %>%\n  addProviderTiles(provider = providers$Esri.WorldImagery,group = \"Satelital\") %>% \n  addCircleMarkers(\n    popup = dataset_pca$village,\n    color = ~paleta(pca_group_4),\n    opacity = 1,\n    radius = 0.1,\n    fillOpacity = 0.5\n    )%>% \n  addLayersControl(\n    baseGroups = c(\"CartoDB\",\"OpenStreetMap\",\"Satelital\")\n    ) %>% \n  addLegend(\n    title = \"Cluster\",\n    pal = paleta,\n    values = ~pca_group_4,\n    opacity = 1,\n    position = \"bottomright\"\n    )\n```\n:::\n\n### 🔵 Comparison\n\nComparison between clustering and PCA: We assessed how well the clustering matched using agglomerative clustering and PCA for 2, 3 and 4 groups. Confusion matrices and the Kappa statistic were used to assess clustering agreement.\n\n#### 2 groups\n\n```{r}\ndataset_pca %>% \n  conf_mat(hc_group_2, pca_group_2, dnn = c(\"PCA\", \"HC\"))\n```\n\n```{r}\ndataset_pca %>% \n  kap(hc_group_2, pca_group_2)\n```\n\n#### 3 groups\n\n```{r}\ndataset_pca %>% \n  conf_mat(hc_group_3, pca_group_3, dnn = c(\"PCA\", \"HC\"))\n```\n\n```{r}\ndataset_pca %>% \n  kap(hc_group_3, pca_group_3)\n```\n\n#### 4 groups\n\n```{r}\ndataset_pca %>% \n  conf_mat(hc_group_4, pca_group_4, dnn = c(\"PCA\", \"HC\"))\n```\n\n```{r}\ndataset_pca %>% \n  kap(hc_group_4, pca_group_4)\n```\n\n## Sampling\n\nSelection of the sample of communities: Having chosen the number of clusters, random sampling proceeded within each cluster proportional to the cluster size.\n\n```{r}\nset.seed(2022)\nsampling_20 = dataset_pca %>% \n  group_by(hc_group_2) %>% \n  slice_sample(prop = signif(20/56, 1)) %>% \n  ungroup()\n\nset.seed(2022)\nsampling_10 = dataset_pca %>% \n  group_by(hc_group_2) %>% \n  slice_sample(prop = signif(10/56, 1)) %>% \n  ungroup()\n```\n\n```{r}\nfull_dataset = dataset_pca %>% \n  st_as_sf(coords = c(\"lon\", \"lat\"))\nsample_10_dataset = sampling_10 %>% \n  st_as_sf(coords = c(\"lon\", \"lat\"))\nsample_20_dataset = sampling_20 %>% \n  st_as_sf(coords = c(\"lon\", \"lat\"))\n```\n\n::: panel-tabset\n## 10 samples\n\n```{r}\n#| echo: false\n#| warning: false\n#| message: false\npaleta = colorFactor(palette = \"viridis\",domain = sample_10_dataset$hc_group_4)\n\nsample_10_dataset %>% \n  leaflet() %>% \n  addTiles(group = \"OpenStreetMap\") %>% \n  addProviderTiles(provider = providers$CartoDB,group = \"CartoDB\") %>%\n  addProviderTiles(provider = providers$Esri.WorldImagery,group = \"Satelital\") %>%\n  addCircleMarkers(\n    data = full_dataset,\n    opacity = 1,\n    radius = 0.1,\n    fillOpacity = 0.5, \n    color = \"lightgray\"\n    ) %>% \n  addCircleMarkers(\n    popup = sample_20_dataset$village,\n    color = ~paleta(hc_group_4),\n    opacity = 1,\n    radius = 0.1,\n    fillOpacity = 0.5\n    )%>% \n  addLayersControl(\n    baseGroups = c(\"CartoDB\",\"OpenStreetMap\",\"Satelital\")\n    ) %>% \n  addLegend(\n    title = \"Cluster\",\n    pal = paleta,\n    values = ~hc_group_4,\n    opacity = 1,\n    position = \"bottomright\"\n    )\n```\n\n## 20 samples\n\n```{r}\n#| echo: false\n#| warning: false\n#| message: false\npaleta = colorFactor(palette = \"viridis\",domain = sample_20_dataset$hc_group_4)\nsample_20_dataset %>% \n  leaflet() %>% \n  addTiles(group = \"OpenStreetMap\") %>% \n  addProviderTiles(provider = providers$CartoDB,group = \"CartoDB\") %>%\n  addProviderTiles(provider = providers$Esri.WorldImagery,group = \"Satelital\") %>% \n  addCircleMarkers(\n    data = full_dataset,\n    opacity = 1,\n    radius = 0.1,\n    fillOpacity = 0.5, \n    color = \"lightgray\"\n    ) %>% \n  addCircleMarkers(\n    popup = sample_20_dataset$village,\n    color = ~paleta(hc_group_4),\n    opacity = 1,\n    radius = 0.1,\n    fillOpacity = 0.5\n    )%>% \n  addLayersControl(\n    baseGroups = c(\"CartoDB\",\"OpenStreetMap\",\"Satelital\")\n    ) %>% \n  addLegend(\n    title = \"Cluster\",\n    pal = paleta,\n    values = ~hc_group_4,\n    opacity = 1,\n    position = \"bottomright\"\n    )\n```\n\n## DIRESA proposal\n\n```{r}\n#| echo: false\n#| warning: false\n#| message: false\nvias <- st_read(\"data/first_sampling/first_sampling.gpkg\",layer = \"red_vial\")\nzungarococha <- st_read(\"data/first_sampling/first_sampling.gpkg\",layer = \"zungarococha\")\niquitos_nauta <- st_read(\"data/first_sampling/first_sampling.gpkg\",layer = \"iquitos_nauta\")\n  \nm1 = mapview(\n  vias,\n  layer.name = \"Red vial\",\n  color = \"red\")\n\nm2 = mapview(\n  zungarococha,\n  layer.name = \"Centro poblados en la carretera Zungarococha\",\n  col.regions = \"green\")\n\nm3 = mapview(\n  iquitos_nauta,\n  layer.name = \"Centro poblados en la carretera Iquitos - Nauta\",\n  col.regions = \"blue\")\n\nm1 + m2 + m3\n```\n:::\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.scss"],"toc":true,"number-sections":true,"output-file":"methodology.html"},"language":{"code-summary":"Show code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.122","editor":"visual","theme":"cosmo","title":"Stratification and sampling️ of population centers in Loreto, Peru 🎲✨"},"extensions":{"book":{"multiFile":true}}}}}